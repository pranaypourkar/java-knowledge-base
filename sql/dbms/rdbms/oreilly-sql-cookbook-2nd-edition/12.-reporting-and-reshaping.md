# 12. Reporting and Reshaping

## Pivoting a Result Set into One Row

We want to take values from groups of rows and turn those values into columns in a single row per group.

**Sample Input**

<figure><img src="../../../../.gitbook/assets/image (136).png" alt="" width="122"><figcaption></figcaption></figure>

**Sample Output**

<figure><img src="../../../../.gitbook/assets/image (138).png" alt="" width="230"><figcaption></figcaption></figure>

```
select 
    sum(case when deptno=10 then 1 else 0 end) as deptno_10,
    sum(case when deptno=20 then 1 else 0 end) as deptno_20,
    sum(case when deptno=30 then 1 else 0 end) as deptno_30
from emp
```

## Pivoting a Result Set into Multiple Rows

We want to turn rows into columns by creating a column corresponding to each of the values in a single given column.

**Sample Input**

<figure><img src="../../../../.gitbook/assets/image (139).png" alt="" width="114"><figcaption></figcaption></figure>

Sample Output

<figure><img src="../../../../.gitbook/assets/image (140).png" alt="" width="251"><figcaption></figcaption></figure>

```
select 
    max(case when job='CLERK' then ename else null end) as clerks,
    max(case when job='ANALYST' then ename else null end) as analysts,
    max(case when job='MANAGER' then ename else null end) as mgrs,
    max(case when job='PRESIDENT' then ename else null end) as prez,
    max(case when job='SALESMAN' then ename else null end) as sales
from (
 select job,
 ename,
 row_number()over(partition by job order by ename) rn
 from emp
) x
group by rn
```

**Explanation**

**Step 1:**

```
select job,
ename,
row_number()over(partition by job order by ename) rn
from emp
```

<figure><img src="../../../../.gitbook/assets/image (141).png" alt="" width="302"><figcaption></figcaption></figure>

Step 2:

```
select rn,
case when job='CLERK' then ename else null end as clerks,
case when job='ANALYST' then ename else null end as analysts,
case when job='MANAGER' then ename else null end as mgrs,
case when job='PRESIDENT' then ename else null end as prez,
case when job='SALESMAN' then ename else null end as sales
from (
select job,
ename,
row_number()over(partition by job order by ename) rn
from emp
) x
```

<figure><img src="../../../../.gitbook/assets/image (142).png" alt="" width="423"><figcaption></figcaption></figure>

Note the blank spaces are null value. To remove the NULLs, use the aggregate function MAX or MIN and group by RN.



<figure><img src="../../../../.gitbook/assets/image (143).png" alt="" width="284"><figcaption></figcaption></figure>

## Reverse Pivoting a Result Set

We want to transform columns to rows.

Sample Input

<figure><img src="../../../../.gitbook/assets/image (144).png" alt="" width="232"><figcaption></figcaption></figure>

Sample Output

<figure><img src="../../../../.gitbook/assets/image (145).png" alt="" width="165"><figcaption></figcaption></figure>

```
select 
    dept.deptno,
    case dept.deptno
        when 10 then emp_cnts.deptno_10
        when 20 then emp_cnts.deptno_20
        when 30 then emp_cnts.deptno_30
        end as counts_by_dept
from emp_cnts cross join
(select deptno from dept where deptno <= 30) dept
```

**Explanation**

```
select * from EMP_CNTS;
```

<figure><img src="../../../../.gitbook/assets/image (146).png" alt="" width="222"><figcaption></figcaption></figure>

There are three columns, and we need to create three rows. Begin by creating a Cartesian product between inline view EMP\_CNTS and some table expression that has at least three rows. Following sample code uses table DEPT to create the Cartesian product. The Cartesian product enables you to return a row for each column in inline view EMP\_CNTS.

```
select dept.deptno,
    emp_cnts.deptno_10,
    emp_cnts.deptno_20,
    emp_cnts.deptno_30
from (
    Select 
        sum(case when deptno=10 then 1 else 0 end) as deptno_10,
        sum(case when deptno=20 then 1 else 0 end) as deptno_20,
        sum(case when deptno=30 then 1 else 0 end) as deptno_30
    from emp
) emp_cnts,
(select deptno from dept where deptno <= 30) dept
```

<figure><img src="../../../../.gitbook/assets/image (147).png" alt="" width="242"><figcaption></figcaption></figure>

## Reverse Pivoting a Result Set into One Column

We want to return all columns from a query as just one column

Sample Output

<figure><img src="../../../../.gitbook/assets/image (148).png" alt="" width="74"><figcaption></figcaption></figure>

Use the window function ROW\_NUMBER OVER to rank each row based on EMPNO (1â€“4). Then use a CASE expression to transform three columns into one.

```
with four_rows (id)
as
(
    select 1
    union all
    select id+1
    from four_rows
    where id < 4
)
 ,
 x_tab (ename,job,sal,rn )
 as
 (
    select e.ename,e.job,e.sal,
     row_number()over(partition by e.empno order by e.empno)
     from emp e
     join four_rows on 1=1
 )

 select
 case rn
     when 1 then ename
     when 2 then job
     when 3 then cast(sal as char(4))
 end emps
 from x_tab
```

Explanation

**Step 1**: Use the window function ROW\_NUMBER OVER to create a ranking for each employee in DEPTNO 10

<figure><img src="../../../../.gitbook/assets/image (149).png" alt="" width="296"><figcaption></figcaption></figure>

**Step 2**: Add the Cartesian product

<figure><img src="../../../../.gitbook/assets/image (150).png" alt="" width="316"><figcaption></figcaption></figure>

**Step 3**: Use a CASE expression to put ENAME, JOB, and SAL into one column for each employee





